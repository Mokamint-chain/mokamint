/*
Copyright 2023 Fausto Spoto

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package io.mokamint.node.local.internal.blockchain;

import static java.util.concurrent.TimeUnit.MILLISECONDS;

import java.io.IOException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.SignatureException;
import java.time.Duration;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.temporal.ChronoUnit;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeoutException;
import java.util.logging.Level;
import java.util.logging.Logger;

import io.mokamint.miner.api.Miner;
import io.mokamint.node.Blocks;
import io.mokamint.node.api.Block;
import io.mokamint.node.api.DatabaseException;
import io.mokamint.node.local.api.LocalNodeConfig;
import io.mokamint.node.local.internal.ClosedDatabaseException;
import io.mokamint.node.local.internal.LocalNodeImpl;
import io.mokamint.node.local.internal.LocalNodeImpl.Event;
import io.mokamint.node.local.internal.LocalNodeImpl.Task;
import io.mokamint.node.local.internal.NodeMiners;
import io.mokamint.node.messages.WhisperBlockMessages;
import io.mokamint.nonce.api.Deadline;
import io.mokamint.nonce.api.DeadlineDescription;
import io.mokamint.nonce.api.IllegalDeadlineException;

/**
 * A task that mines a new block, above a previous block.
 * It requests a deadline to the miners of the node
 * and waits for the best deadline to expire.
 * Once expired, it builds the block and signals a new block discovery to the node.
 * This task assumes that the blockchain is not empty.
 */
public class MineNewBlockTask implements Task {
	private final static Logger LOGGER = Logger.getLogger(MineNewBlockTask.class.getName());

	/**
	 * The start of the log messages generated by this task.
	 */
	private volatile String logPrefix;

	/**
	 * The description of this task.
	 */
	private volatile String toString;

	/**
	 * The node performing the mining.
	 */
	private final LocalNodeImpl node;

	/**
	 * The blockchain of the node.
	 */
	private final Blockchain blockchain;

	/**
	 * The configuration of the node running this task.
	 */
	private final LocalNodeConfig config;

	/**
	 * The miners of the node.
	 */
	private final NodeMiners miners;

	/**
	 * Creates a task that mines a new block.
	 * 
	 * @param node the node performing the mining
	 */
	MineNewBlockTask(LocalNodeImpl node) {
		this.node = node;
		this.blockchain = node.getBlockchain();
		this.config = node.getConfig();
		this.miners = node.getMiners();
		this.logPrefix = "";
		this.toString = "next block mining";

		// we interrupt already existing mining tasks, since this new task will likely mine on a more promising chain
		blockchain.interruptAllMiningTasks();
	}

	@Override
	public String logPrefix() {
		return logPrefix;
	}

	@Override
	public String toString() {
		return toString;
	}

	@Override
	public void body() throws NoSuchAlgorithmException, DatabaseException, ClosedDatabaseException, InterruptedException, InvalidKeyException, SignatureException {
		if (blockchain.isEmpty())
			LOGGER.log(Level.SEVERE, logPrefix + "cannot mine on an empty blockchain");
		else if (miners.get().count() == 0L) {
			LOGGER.log(Level.WARNING, logPrefix + "cannot mine because this node currently has no miners attached");
			node.onNoMinersAvailable();
		}
		else {
			try {
				// only one mining task is allowed at a time, since concurrent mining would make
				// the application API too complex and require applications to track more blocks open at the same time
				blockchain.acquireMiningLock();
				new Run();
			}
			finally {
				blockchain.releaseMiningLock();
			}
		}
	}

	/**
	 * An event fired to signal that the connection to a miner timed-out.
	 */
	public class IllegalDeadlineEvent implements Event {
		public final Miner miner;
		public final long points;

		 /**
		  * Creates an event that expresses a miner's misbehavior.
		  * 
		  * @param miner the miner that misbehaved
		  */
		private IllegalDeadlineEvent(Miner miner) {
			this.miner = miner;
			this.points = config.getMinerPunishmentForIllegalDeadline();
		}

		@Override
		public String toString() {
			return "miner " + miner.getUUID() + " computed an illegal deadline event [" + points + " points]";
		}

		@Override
		public void body() throws IOException {
			miners.punish(miner, points);
		}

		@Override
		public String logPrefix() {
			return logPrefix;
		}
	}

	/**
	 * An event fired to signal that a block has been mined.
	 * It adds it to the blockchain and whispers it to all peers.
	 */
	public class BlockMinedEvent implements Event {
		public final Block block;
		public final String hexBlockHash;

		private BlockMinedEvent(Block block) {
			this.block = block;
			this.hexBlockHash = block.getHexHash(config.getHashingForBlocks());
		}

		@Override
		public String toString() {
			return "block mined event for block " + hexBlockHash;
		}

		@Override
		public void body() throws DatabaseException, NoSuchAlgorithmException, VerificationException, ClosedDatabaseException {
			if (blockchain.add(block)) {
				LOGGER.info(logPrefix + "whispering block " + hexBlockHash + " to all peers");
				node.whisper(WhisperBlockMessages.of(block, UUID.randomUUID().toString()), _whisperer -> false);
			}
		}

		@Override
		public String logPrefix() {
			return logPrefix;
		}
	}

	/**
	 * Run environment.
	 */
	private class Run {

		/**
		 * The block over which mining is performed.
		 */
		private final Block previous;

		/**
		 * The height of the new block that is being mined.
		 */
		private final long heightOfNewBlock;

		/**
		 * The hexadecimal representation of the hash of the parent block of the
		 * block being mined by this task.
		 */
		private final String previousHex;

		/**
		 * The moment when the previous block has been mined. From that moment we
		 * count the time to wait for the deadline.
		 */
		private final LocalDateTime startTime;

		/**
		 * The description of the deadline required for the next block.
		 */
		private final DeadlineDescription description;

		/**
		 * The best deadline computed so far. This is empty until a first deadline is found. Since more miners
		 * might work for a node, this deadline might change more than once, to increasingly better deadlines.
		 */
		private final ImprovableDeadline currentDeadline = new ImprovableDeadline();

		/**
		 * The waker used to wait for a deadline to expire.
		 */
		private final Waker waker = new Waker();

		/**
		 * The set of miners that did not answer so far with a legal deadline.
		 */
		private Set<Miner> minersThatDidNotAnswer = ConcurrentHashMap.newKeySet();

		/**
		 * Set to true when the task has completed, also in the case when
		 * it could not find any deadline.
		 */
		private final boolean done;

		private Run() throws InterruptedException, DatabaseException, NoSuchAlgorithmException, ClosedDatabaseException, InvalidKeyException, SignatureException {
			this.previous = blockchain.getHead().get();
			this.heightOfNewBlock = previous.getHeight() + 1;
			this.previousHex = previous.getHexHash(config.getHashingForBlocks());
			logPrefix = "height " + heightOfNewBlock + ": ";
			toString = "next block mining on top of block " + previousHex;
			this.startTime = blockchain.getGenesis().get().getStartDateTimeUTC().plus(previous.getTotalWaitingTime(), ChronoUnit.MILLIS);
			this.description = previous.getNextDeadlineDescription(config.getHashingForGenerations(), config.getHashingForDeadlines());

			try {
				requestDeadlineToEveryMiner();
				waitUntilFirstDeadlineArrives();
				waitUntilDeadlineExpires();
				createNewBlock().ifPresent(this::informNodeAboutNewBlock);
			}
			catch (TimeoutException e) {
				LOGGER.warning(logPrefix + MineNewBlockTask.this + ": no deadline found (timed out while waiting for a deadline)");
				node.submit(new DelayedMineNewBlockTask(node));
				node.onNoDeadlineFound(previous);
			}
			finally {
				turnWakerOff();
				punishMinersThatDidNotAnswer();
				this.done = true;
			}
		}

		private void requestDeadlineToEveryMiner() {
			miners.get().forEach(this::requestDeadlineTo);
		}

		private void requestDeadlineTo(Miner miner) {
			if (Thread.currentThread().isInterrupted()) {
				LOGGER.info(logPrefix + "not creating block on top of " + previousHex + " since the task has been interrupted");
				return;
			}

			LOGGER.info(logPrefix + "asking miner " + miner.getUUID() + " for a deadline: " + description);
			minersThatDidNotAnswer.add(miner);
			miner.requestDeadline(description, deadline -> onDeadlineComputed(deadline, miner));
		}

		private void waitUntilFirstDeadlineArrives() throws InterruptedException, TimeoutException {
			currentDeadline.await(config.getDeadlineWaitTimeout(), MILLISECONDS);
		}

		private void informNodeAboutNewBlock(Block block) {
			node.submit(new BlockMinedEvent(block));
		}

		/**
		 * Called by miners when they find a deadline.
		 * 
		 * @param deadline the deadline that has just been computed
		 * @param miner the miner that found the deadline
		 */
		private void onDeadlineComputed(Deadline deadline, Miner miner) {
			LOGGER.info(logPrefix + "miner " + miner.getUUID() + " sent deadline " + deadline);

			if (done)
				LOGGER.warning(logPrefix + "discarding deadline " + deadline + " since it arrived too late");
			else {
				try {
					deadline.matchesOrThrow(description, IllegalDeadlineException::new);
					node.check(deadline);

					// we increase the points of the miner, but only for the first deadline that it provides
					if (minersThatDidNotAnswer.remove(miner))
						miners.pardon(miner, config.getMinerPunishmentForTimeout());

					if (!currentDeadline.isWorseThan(deadline))
						LOGGER.info(logPrefix + "discarding deadline " + deadline + " since it is not better than the current deadline");
					else {
						if (currentDeadline.updateIfWorseThan(deadline)) {
							LOGGER.info(logPrefix + "improved deadline to " + deadline);
							setWaker(deadline);
						}
						else
							LOGGER.info(logPrefix + "discarding deadline " + deadline + " since it is not better than the current deadline");
					}
				}
				catch (IllegalDeadlineException e) {
					LOGGER.warning(logPrefix + "discarding deadline " + deadline + " since it is illegal: " + e.getMessage());
					node.submit(new IllegalDeadlineEvent(miner));
				}
			}
		}

		private void waitUntilDeadlineExpires() throws InterruptedException {
			waker.await();
		}

		/**
		 * Creates the new block. This might be missing if it realizes that it would be worse
		 * than the current head of the blockchain: useless to execute and verify the transactions
		 * if it does not win the race.
		 * 
		 * @return the block, if any
		 * @throws DatabaseException if the database is corrupted
		 * @throws ClosedDatabaseException if the database is already closed
		 * @throws SignatureException if the block could not be signed
		 * @throws InvalidKeyException if the private key of the node is invalid
		 */
		private Optional<Block> createNewBlock() throws DatabaseException, ClosedDatabaseException, InvalidKeyException, SignatureException {
			var deadline = currentDeadline.get().get(); // here, we know that a deadline has been computed
			var description = previous.getNextBlockDescription(deadline, config.getTargetBlockCreationTime(), config.getHashingForBlocks(), config.getHashingForDeadlines());
			var powerOfHead = blockchain.getPowerOfHead();
			if (powerOfHead.isPresent() && powerOfHead.get().compareTo(description.getPower()) >= 0) {
				LOGGER.info(logPrefix + "not creating block on top of " + previousHex + " since it would not improve the head");
				return Optional.empty();
			}

			var nextBlock = Blocks.of(description.getHeight(), description.getPower(), description.getTotalWaitingTime(),
				description.getWeightedWaitingTime(), description.getAcceleration(), description.getDeadline(), description.getHashOfPreviousBlock(),
				node.getKeys().getPrivate());

			if (Thread.currentThread().isInterrupted()) {
				LOGGER.info(logPrefix + "not creating block on top of " + previousHex + " since the task has been interrupted");
				return Optional.empty();
			}

			// TODO: transactions should be added here

			return Optional.of(nextBlock);
		}

		/**
		 * Sets a waker at the expiration of the given deadline.
		 * 
		 * @param deadline the deadline
		 */
		private void setWaker(Deadline deadline) {
			long millisecondsToWait = deadline.getMillisecondsToWaitFor(previous.getAcceleration());
			long millisecondsAlreadyPassed = Duration.between(startTime, LocalDateTime.now(ZoneId.of("UTC"))).toMillis();
			long stillToWait = millisecondsToWait - millisecondsAlreadyPassed;
			if (waker.set(stillToWait))
				LOGGER.info(logPrefix + "set up a waker in " + stillToWait + " ms");
		}

		private void turnWakerOff() {
			waker.shutdownNow();
		}

		private void punishMinersThatDidNotAnswer() {
			minersThatDidNotAnswer.forEach(this::punishMinerThatDidNotAnswer);
		}

		private void punishMinerThatDidNotAnswer(Miner miner) {
			try {
				miners.punish(miner, config.getMinerPunishmentForTimeout());
			}
			catch (IOException e) {
				LOGGER.log(Level.SEVERE, logPrefix + "cannot punish miner " + miner + " that did not answer: " + e.getMessage());
			}
		}
	}
}